/*
-----------------------------------------------------------------------------
Filename:    HoleInTheWall.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "StdAfx.h"
//#include "HoleInTheWall.h"
#include "SinbadCharacterController.h"
#include "HoleInTheWall.h"
using namespace Ogre;
using namespace OgreBites;
#define LIMIT_PERC 0.09
extern std::vector<IncomingWall*> Walls;
extern Ogre::SceneNode* wallNode;
//extern Entity* fitIndicator;
extern Entity* fitIndicatorTop;
extern Entity* fitIndicatorLeft;
extern Entity* fitIndicatorRight;
//extern int activeWall=-1;
extern TexturePtr depthTexture;
bool passed=false;
float speed=START_SPEED;
float mod_speed=0;
int g_livesLeft=3;

void HoleInTheWall::createHoleRoom(Real roomWidth,Real roomHeight)
{
	//Create The Scene Nodes
	Ogre::SceneNode* roomNode=mSceneMgr->getRootSceneNode()->createChildSceneNode("roomNode");
	Ogre::SceneNode* leftWallNode=roomNode->createChildSceneNode("LeftWallNode",Vector3(0,roomHeight/2,roomWidth/2));
	Ogre::SceneNode* rightWallNode=roomNode->createChildSceneNode("RightWallNode",Vector3(0,roomHeight/2,-roomWidth/2));
	Ogre::SceneNode* roofNode=roomNode->createChildSceneNode("RoofNode",Vector3(0,roomHeight,0));
	Ogre::SceneNode* pathNode=roomNode->createChildSceneNode("pathNode");
	Ogre::SceneNode* endWallNode=roomNode->createChildSceneNode("endWallNode",Vector3(-50,roomHeight/2,0));
	roofNode->yaw(Radian(Math::PI/2));
	//roofNode->roll(Radian(-Math::PI/2));
	rightWallNode->pitch(Radian(Math::PI));

	//path Plane 
	MeshManager::getSingleton().createPlane("path", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(Vector3::UNIT_Y, 0),100, IncomingWallWidth, 1, 1, true, 1, 1, 1, Vector3::UNIT_Z);

	//Wall Plane 
	MeshManager::getSingleton().createPlane("sideWall", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(-Vector3::UNIT_Z, 0),roomHeight, 100, 1, 1, true, 1, 1, 1, Vector3::UNIT_X);

		MeshManager::getSingleton().createPlane("roofPlane", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(-Vector3::UNIT_Y, 0),roomHeight, 100, 1, 5, true, 1, 1, 5, Vector3::UNIT_Z);

	//Small Wall Plane
			MeshManager::getSingleton().createPlane("endWall", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(Vector3::UNIT_X, 0),roomWidth, roomHeight, 3, 1, true, 1, 3, 1, Vector3::UNIT_Y);

			MeshManager::getSingleton().createPlane("lightWall", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(Vector3::UNIT_X, 0),roomWidth/3, roomHeight, 10, 10, true, 1, 10, 10, Vector3::UNIT_Y);
				
	//Create smaller wall and floor
	Entity* path= mSceneMgr->createEntity("Path","path");
	path->setMaterialName("carpet_mat");
	path->setCastShadows(false);
	pathNode->attachObject(path);
	pathNode->translate(0,0.01,0);

	Entity* endWall= mSceneMgr->createEntity("EndWall","endWall");
	endWall->setMaterialName("back_mat");
	endWall->setCastShadows(false);
	endWallNode->attachObject(endWall);

	//Create Walls
	Entity* leftWall=mSceneMgr->createEntity("LeftWall","sideWall");
	leftWall->setMaterialName("audience_mat");
	leftWall->setCastShadows(false);

	Entity* rightWall=leftWall->clone("RightWall");
	
	Entity* roof=mSceneMgr->createEntity("Roof","roofPlane");
	roof->setMaterialName("path_mat");
	roof->setCastShadows(false);
	


	Entity* lightWall=mSceneMgr->createEntity("LightWall","lightWall");
	lightWall->setMaterialName("light_mat");
	lightWall->setCastShadows(false);
	endWallNode->createChildSceneNode("lightWallNode",Vector3(0.005,0,0))->attachObject(lightWall);

	//Add walls to scene
	leftWallNode->attachObject(leftWall);
	rightWallNode->attachObject(rightWall);
	rightWallNode->scale(1,-1,1);
	roofNode->attachObject(roof);


		
}

void SetupDepthMaterial()
{
	// Create the texture
	depthTexture = TextureManager::getSingleton().createManual(
			"MyDepthTexture", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
			TEX_TYPE_2D,      // type
			m_Width, m_Height,         // width & height
			0,                // number of mipmaps
			PF_BYTE_BGRA,     // pixel format
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);

		
	// Create a material using the texture
	MaterialPtr material = MaterialManager::getSingleton().create(
			"DepthTextureMaterial", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	material->getTechnique(0)->getPass(0)->createTextureUnitState("MyDepthTexture");
	material->getTechnique(0)->getPass(0)->setSceneBlending(SBT_TRANSPARENT_ALPHA);
}

void deactivateWall(int index)
{
	if(index>=0 && index<Walls.size())
	{
		Walls.at(index)->getWall()->setVisible(false);
	}
}

void activateWall(int index)
{
	if(index>=0 && index<Walls.size())
	{

		Walls.at(index)->getWall()->setVisible(true);
		activeWall=index;
	}
}

void SetupRGBMaterial()
{
	Ogre::TexturePtr depthTexture = Ogre::TextureManager::getSingleton().createManual(
			"MyRGBTexture", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
			TEX_TYPE_2D,      // type
			RGBX, RGBY,         // width & height
			0,                // number of mipmaps
			PF_BYTE_RGB,     // pixel format
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);

		
	// Create a material using the texture
	MaterialPtr material = MaterialManager::getSingleton().create(
			"RGBTextureMaterial", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
	material->getTechnique(0)->getPass(0)->createTextureUnitState("MyRGBTexture");
}

void  HoleInTheWall::processWall(const FrameEvent& evt,float outPerc)
{

	if (outPerc!=-1)//If the user is calibrated
	{
		mStart->hide();
		if (mStatus==PROGRESS)
		{
			wallNode->translate(evt.timeSinceLastFrame*(speed+mod_speed),0,0);
			if(outPerc>LIMIT_PERC)//Check if the user hit the wall
			{//If there is a hit
				fitIndicatorTop->setMaterialName("unfit_mat");
				fitIndicatorLeft->setMaterialName("unfit_mat");
				fitIndicatorRight->setMaterialName("unfit_mat");
				mod_speed=0;
			}
			else
			{
				fitIndicatorTop->setMaterialName("fit_mat");
				fitIndicatorLeft->setMaterialName("fit_mat");
				fitIndicatorRight->setMaterialName("fit_mat");
				mod_speed+=evt.timeSinceLastFrame*20;
			}

			if (abs(wallNode->getPosition().x-mChara->mBodyNode->getPosition().x)<2)//If the user and the wall are aligned
			{
				passed=true; 
				if(outPerc>LIMIT_PERC)//Check if the user hit the wall
				{//If there is a hit
					wallNode->setPosition(-49.96,IncomingWallHeight/2,0); //Reset the wall position
					passed=false;		//Reset passed flag
					if (g_livesLeft==1)		//If this was the last life, the player died
					{
						mDeath->show();
						mStatus=DEATH;
						deactivateWall(activeWall);
						activateWall(0);	//Revert to the first wall
						speed=START_SPEED;	//Reset the speed		
						mLives[1]->show();
						mLives[2]->show();
						g_livesLeft=3;
					}						//Continue play if there are more lives
					else
					{		
						mChara->takeSnapshot();
						mPhoto->show();
						mFailure->show();
						mStatus=FAILURE;
						g_livesLeft--;
						mLives[g_livesLeft]->hide();
					}
				}
			}
			else
			{
				if(passed)//If the wall is behind the user, it means user was successful
				{
					speed+=SPEED_INCREASE;	//Increase the speed
					wallNode->setPosition(-49.96,IncomingWallHeight/2,0);//Reset the wall position
					deactivateWall(activeWall);
					if(++activeWall==Walls.size())	//Proceed to the next wall
						activeWall=0;
					activateWall(activeWall);		//
					passed=false;					//Reset the passed flag
					mSuccess->show();	//Show the success indicator
					mStatus=SUCCESS;
					mChara->takeSnapshot();
					mPhoto->show();
				}
			}
		}
		else	//If there is a logo going on
		{
			mod_speed=0;
			LogoTime+=evt.timeSinceLastFrame*1000;
			if (LogoTime>=1000)
			{
				
				mStatus=PROGRESS;
				LogoTime=0;
				mSuccess->hide();
				mFailure->hide();
				mDeath->hide();
				mPhoto->hide();
			}
		}
	}
	else//If the user is not calibrated
	{
		wallNode->setPosition(-49.96,IncomingWallHeight/2,0);//Reset the Wall position
		mStart->show();
		mSuccess->hide();
		mFailure->hide();
		mDeath->hide();
		mStatus=PROGRESS;
		LogoTime=0;
		mod_speed=0;
	}
}

bool HoleInTheWall::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	// let character update animations and camera
	float outPerc=mChara->addTime(evt.timeSinceLastFrame);
	
	Ogre::Vector3 tt=mCamera->getPosition();
	tt=mCamera->getDirection();
-1	help->setParamValue("Out_Perc",StringConverter::toString( (float)outPerc ));
	processWall(evt,outPerc);//Process the incoming wall
	return BaseApplication::frameRenderingQueued(evt);

	//Update Wall Stuff
}

void HoleInTheWall::setupContent()
{   
	// set background and some fog
	mSceneMgr->setSkyDome(true, "NightSky", 5, 8);
	// set shadow properties
	mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_MODULATIVE);
	mSceneMgr->setShadowColour(ColourValue(0.5, 0.5, 0.5));
	mSceneMgr->setShadowTextureSize(1024);
	mSceneMgr->setShadowTextureCount(1);

	// use a small amount of ambient lighting
	mSceneMgr->setAmbientLight(ColourValue(0.3, 0.3, 0.3));

	// add a bright light above the scene
	Light* light = mSceneMgr->createLight();
	light->setType(Light::LT_POINT);
	light->setPosition(-10, 40, 0);
	light->setDiffuseColour(ColourValue::White);
	light->setSpecularColour(ColourValue::White);

	light = mSceneMgr->createLight();
	light->setType(Light::LT_POINT);
	light->setPosition(-40, 10, 0);
	light->setDiffuseColour(ColourValue::White);
	light->setSpecularColour(ColourValue::White);

		light = mSceneMgr->createLight();
	light->setType(Light::LT_POINT);
	light->setPosition(-30, 10, 0);
	light->setDiffuseColour(ColourValue::White);
	light->setSpecularColour(ColourValue::White);

	// create a floor mesh resource
	MeshManager::getSingleton().createPlane("floor", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
	Plane(Vector3::UNIT_Y, 0),100, 100, 10, 10, true, 1, 10, 10, Vector3::UNIT_Z);

	StringVector items;
	items.push_back("Mirror");
	items.push_back("Smoothing");
	items.push_back("Out_Perc");
	help = mTrayMgr->createParamsPanel(TL_TOPLEFT, "HelpMessage", 200, items);
	
	// create our character controller
	mChara = new SinbadCharacterController(mCamera);
	mChara->m_help = help;
	mChara->m_pTrayMgr = mTrayMgr;
	
	mTrayMgr->toggleAdvancedFrameStats();

	SetupDepthMaterial();
	SetupRGBMaterial();

	// create a floor entity, give it a material, and place it at the origin
    Entity* floor = mSceneMgr->createEntity("Floor", "floor");
    floor->setMaterialName("floor_mat");
	floor->setCastShadows(false);
	mSceneMgr->getRootSceneNode()->attachObject(floor);

	initWallResources(mSceneMgr);
	createHoleRoom(80,30);
	IncomingWall* Wall1=new IncomingWall(mSceneMgr,"standingDude","WallTextureMaterial1");
	IncomingWall* Wall2=new IncomingWall(mSceneMgr,"runningDude","WallTextureMaterial2");
	IncomingWall* Wall3=new IncomingWall(mSceneMgr,"pissingBaby","WallTextureMaterial3");
	IncomingWall* Wall4=new IncomingWall(mSceneMgr,"happy","WallTextureMaterial4");
	IncomingWall* Wall5=new IncomingWall(mSceneMgr,"dancingDude","WallTextureMaterial5");
	IncomingWall* Wall6=new IncomingWall(mSceneMgr,"toilet","WallTextureMaterial6");

	Walls.push_back(Wall1);
	Walls.push_back(Wall2);
	Walls.push_back(Wall3);
	Walls.push_back(Wall4);
	Walls.push_back(Wall5);
	Walls.push_back(Wall6);
	activateWall(0);

	mDepthPanel = Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","DepthPanel");
	mDepthPanel->setMaterialName("DepthTextureMaterial");
	mDepthPanel->setMetricsMode(Ogre::GMM_RELATIVE);
	mDepthPanel->setWidth(0.25);
	mDepthPanel->setHeight(0.25*m_Height/m_Width);
	mDepthPanel->setHorizontalAlignment(GHA_RIGHT);
	mDepthPanel->setVerticalAlignment(GVA_BOTTOM);
	mDepthPanel->setLeft(-mDepthPanel->getWidth());
	mDepthPanel->setTop(-mDepthPanel->getHeight());
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mDepthPanel);
	mDepthPanel->show();

	mLives[0] = Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","Life1");
	mLives[0]->setMaterialName("life_mat");
	mLives[0]->setMetricsMode(Ogre::GMM_RELATIVE);
	mLives[0]->setWidth(0.05);
	mLives[0]->setHeight(0.05);
	mLives[0]->setHorizontalAlignment(GHA_RIGHT);
	mLives[0]->setVerticalAlignment(GVA_TOP);
	mLives[0]->setLeft(-mLives[0]->getWidth());

	mLives[1]=mLives[0]->clone("Life2");
	mLives[1]->setLeft(-mLives[0]->getWidth()*2);

	mLives[2]=mLives[0]->clone("Life3");
	mLives[2]->setLeft(-mLives[0]->getWidth()*3);


	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mLives[0]);
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mLives[1]);
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mLives[2]);



	
	mTrayMgr->hideLogo();
	help->setParamValue("Mirror", "M");
	help->setParamValue("Smoothing", "H/N 0.6");
		
	if(mQuitSlider == NULL)
	{
		mQuitSlider = createYesNoSlider(TL_NONE,"QuitSlider","Quit?",300,200,0,1,10,mTrayMgr);
		mQuitSlider->hide();
	}
		

	mSuccess = Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","Success");//The success and failure indicators
	mSuccess->setMaterialName("success_mat");
	mSuccess->setMetricsMode(Ogre::GMM_RELATIVE);
	mSuccess->setWidth(0.50);
	mSuccess->setHeight(0.50);
	mSuccess->setHorizontalAlignment(GHA_CENTER);
	mSuccess->setVerticalAlignment(GVA_CENTER);
	mSuccess->setLeft(-mSuccess->getWidth()/2);
	mSuccess->setTop(-mSuccess->getHeight()/2);
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mSuccess);
	mSuccess->hide();

	mStart=mSuccess->clone("Start");			//Start indicating Wifget
	mStart->setMaterialName("start_mat");
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mStart);
	mStart->show();
	
	mDeath=mSuccess->clone("Death");			//Start indicating Wifget
	mDeath->setMaterialName("death_mat");
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mDeath);
	mDeath->hide();

	Ogre::Overlay* pOverlay=Ogre::OverlayManager::getSingleton().create("PhotoOverlay");

	mPhoto = Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","PhotoPanel");
	mPhoto->setMaterialName("RGBTextureMaterial");
	mPhoto->setMetricsMode(Ogre::GMM_PIXELS);
	mPhoto->setWidth(RGBX);
	mPhoto->setHeight(RGBY);
	mPhoto->setHorizontalAlignment(GHA_CENTER);
	mPhoto->setVerticalAlignment(GVA_CENTER);
	mPhoto->setLeft(-RGBX/2);
	mPhoto->setTop(-RGBY/2);
	pOverlay->add2D((Ogre::OverlayContainer*)mPhoto);
	pOverlay->setZOrder(mTrayMgr->getTraysLayer()->getZOrder()-2);
	pOverlay->show();
	mPhoto->hide();
	
	mSuccess->setHorizontalAlignment(GHA_CENTER);
	mSuccess->setVerticalAlignment(GVA_BOTTOM);
	mSuccess->setWidth(0.40);
	mSuccess->setHeight(0.40);
	mSuccess->setLeft(-mSuccess->getWidth()/2);
	mSuccess->setTop(-mSuccess->getHeight());

	mFailure=mSuccess->clone("Failure");		//Failure indicating Widget
	mFailure->setMaterialName("failure_mat");
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)mFailure);
	mFailure->hide();

	mChara->m_quitSlider = mQuitSlider;
}

//-------------------------------------------------------------------------------------
HoleInTheWall::HoleInTheWall(void)
{
	mStatus=PROGRESS;
	LogoTime=0;
}
//-------------------------------------------------------------------------------------
HoleInTheWall::~HoleInTheWall(void)
{
		if (mChara) delete mChara;
		MeshManager::getSingleton().remove("floor");
		MeshManager::getSingleton().remove("path");
		MeshManager::getSingleton().remove("sideWall");
		MeshManager::getSingleton().remove("endWall");
		MeshManager::getSingleton().remove("wall");
		MeshManager::getSingleton().remove("fitIndicatorPlane");
		
}

//-------------------------------------------------------------------------------------
void HoleInTheWall::createScene(void)
{
	setupContent();

}




#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        HoleInTheWall app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }
//		exit(0);
        return 0;
    }

#ifdef __cplusplus
}
#endif
